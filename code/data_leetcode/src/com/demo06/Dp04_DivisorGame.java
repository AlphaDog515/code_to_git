package com.demo06;

public class Dp04_DivisorGame {

}
/*
	爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。	
	最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：	
	选出任一 x，满足 0 < x < N 且 N % x == 0 。
	用 N - x 替换黑板上的数字 N 。
	如果玩家无法执行这些操作，就会输掉游戏。	
	只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。
	假设两个玩家都以最佳状态参与游戏。	// 说明玩家每次的选择是最佳选择吗？
	示例 1：	
	输入：2
	输出：true
	解释：爱丽丝选择 1，鲍勃无法进行操作。
	
	示例 2：	
	输入：3
	输出：false
	解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。 
	
	提示：	
	1 <= N <= 1000
	
	分析：
	1.数字N如果是奇数，它的约数必然都是奇数；若为偶数，则其约数可奇可偶。
	2.无论N初始为多大的值，游戏最终只会进行到N=2时结束，那么谁轮到N=2时谁就会赢。
	3.因为爱丽丝先手，N初始若为偶数，爱丽丝则只需一直选1，使鲍勃一直面临N为奇数的情况，这样爱丽丝稳赢；
	4.N初始若为奇数，那么爱丽丝第一次选完之后N必为偶数，那么鲍勃只需一直选1就会稳赢。
	    综述，判断N是奇数还是偶数，即可得出最终结果！

	题目解析
	对于这种博弈类的题目，如果没有思路的话我们不妨多举几个例子，尝试着从中找寻规律。	
	假设 N = 1，爱丽丝没得选择，直接失败，即 鲍勃获胜；
	假设 N = 2，爱丽丝有选择，她可以选择 x = 1，鲍勃面对的就是 N = 2 - 1 = 1，无法操作，爱丽丝获胜；
	假设 N = 3，爱丽丝只能选择 x = 1，因为选 x = 2 不满足 3 % 2 = 0，
		鲍勃面对的就是 N = 3 - 1 = 2，参考上面 N = 2 的情形，此时鲍勃为 N = 2 的先手，鲍勃获胜；
	假设 N = 4，爱丽丝可以选择 x = 1 来使鲍勃遇到 N = 3 的情况，爱丽丝获胜；
	貌似有个规律：N 为奇数时， 鲍勃获胜；N 为偶数时， 爱丽丝获胜。
	
	是这样吗？	
	是的。	
	事实上，无论 N 为多大，最终都是在 N = 2 这个临界点结束的。
	谁最后面对的是 N = 2 的情形，谁就能获胜（这句话不太理解的话，仔细看看 N = 2、N = 3 这两种情形）。
	
	接下来，我们得知道一个数学小知识：奇数的因子（约数）只能是奇数，偶数的因子（约数）可以是奇数或偶数。
	
	千万不要忽略 1 也是因子！
	
	爱丽丝是游戏开始时的先手。
	
	当她面对的 N 为偶数时，她 一定可以选到一个 N 的奇数因子 x（比如 1 ），
	将 N - x 这个奇数传给鲍勃；用 N - x 替换黑板上的数字 N ，鲍勃面对的就是奇数 N，
	只能选择 N 的奇数因子 x，奇数 - 奇数 = 偶数，此时传给爱丽丝的又是偶数。
	这样轮换下去爱丽丝会遇到 N = 2 的情形，然后获胜；
	当爱丽丝遇到的 N 是奇数时，只能传给鲍勃偶数或无法操作 (N = 1) ，无法获胜。


*/

class Solution_4_1 {
	public boolean divisorGame(int N) {
		return N % 2 == 0;
	}
}