

一  创建，查看，删除索引
	#创建索引
	CREATE INDEX 索引名 ON 表名(字段名...);
	#删除索引
	DROP INDEX 索引名 ON 表名;
	#查看索引
	SHOW INDEX FROM 表名;
	

二 创建索引的位置
	select 字段④  from 表名  join  表名  on 字段（条件）①
	where 字段（条件）②
	group by 字段 ③
	having 字段
	order by 字段⑤
	
三 explain进行性能分析
   使用方式 ： explain + sql语句
	id : 用来查看表执行的顺序，如果id越多可以认为子查询嵌套越多（不好）。
   
	table : 显示的执行的表名。如果是虚表名字就是dervied2 
   
	select_type（不重要） ： 代表查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询。
   
	type（很重要） :很重要是一个定性指标 - 一个语句执行的性能好坏全看type
		1.All : 说明没有使用到索引，可以考虑加索引。
		
    possible_keys : 可能使用到的索引
	
	key :实际使用到的索引
	
	key_len(重要) : 使用到的索引的长度。长度越长说明使用到的索引越充分。
	
	eq_ref(不重要) ： 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。
	
	rows（重要） : rows列显示MySQL认为它执行查询时必须检查的行数。越少越好！（不是很精确）
					相同结果下rows的值越少越好。
   
	Extra(重要)：额外的性能指标
			Using filesort ： 说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。
						MySQL中无法利用索引完成的排序操作称为“文件排序”（很严重的问题，需要优化）。
						
			Using temporary ： group by和order by后面的字段的索引没有生效（没使用）造成的。
						在这个结果的后面大多数情况下会有Using filesort，因为先分组后排序。分组没用生排序也就有问题了。
四 单表使用索引：
	1.全值匹配最优。
	2.最佳左前缀法则。
	3.不要在索引列上做任何计算
	4.字符类型上的值必须加''否则索引失效-因为类型转换了。
	5.范围后面的索引全失效
	6.select后面尽量不写*,需要什么字段就写什么字段。否则在分组或过滤的时候索引用不上。
	7.索引字段使用 !=(<>)索引会失效
	8.is not null用不到索引，is null可以用到索引
	9.使用like模糊查询时，前缀如果是%索引会失效。
	10.使用unionAll,union替代or
   
   
五 ：关联表：
	左外连接： 左边的表叫作驱动表，右边的表叫作被驱动表。一般索引都是加在被驱动表上。
    内连接 ：inner join 两张表的数量有多有少？小表驱动大表。
    内连接 ：straight_join但是会强制将左侧作为驱动表！
	

六 ：子查询的优化：
	 1.创建索引
	 2.尽量不要使用子查询
	 3.使用 left join xxx where xxx的 方式替换 not in
   
   
   
   
   
   
	